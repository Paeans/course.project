{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 Physical GPUs, 1 Logical GPUs\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import tensorflow as tf\n",
    "from tensorflow import keras\n",
    "\n",
    "from tensorflow.keras import layers, regularizers\n",
    "\n",
    "gpus = tf.config.experimental.list_physical_devices('GPU')\n",
    "if gpus:\n",
    "  try:\n",
    "    # Currently, memory growth needs to be the same across GPUs\n",
    "    for gpu in gpus:\n",
    "      tf.config.experimental.set_memory_growth(gpu, True)\n",
    "    logical_gpus = tf.config.experimental.list_logical_devices('GPU')\n",
    "    print(len(gpus), \"Physical GPUs,\", len(logical_gpus), \"Logical GPUs\")\n",
    "  except RuntimeError as e:\n",
    "    # Memory growth must be set before GPUs have been initialized\n",
    "    print(e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split, KFold, cross_validate, cross_val_score\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.compose import ColumnTransformer\n",
    "from sklearn.preprocessing import LabelEncoder, OneHotEncoder\n",
    "from sklearn.impute import SimpleImputer\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from xgboost import XGBClassifier\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score\n",
    "from sklearn.metrics import roc_curve, auc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "data = pd.read_csv('hotel_bookings.csv')\n",
    "data_cln = data.fillna({'children': 0.0, 'country': 'Unknown', 'agent':0, 'company': 0})\n",
    "data_cln['meal'].replace('Undefined', 'SC', inplace = True)\n",
    "\n",
    "num_features = [\"lead_time\",\"arrival_date_week_number\",\"arrival_date_day_of_month\",\n",
    "                \"stays_in_weekend_nights\",\"stays_in_week_nights\",\"adults\",\"children\",\n",
    "                \"babies\",\"is_repeated_guest\", \"previous_cancellations\",\n",
    "                \"previous_bookings_not_canceled\",\"agent\",\"company\",\n",
    "                \"required_car_parking_spaces\", \"total_of_special_requests\", \"adr\"]\n",
    "\n",
    "cat_features = [\"arrival_date_month\",\"meal\",\"market_segment\",\n",
    "                \"distribution_channel\",\"reserved_room_type\",\"deposit_type\",\"customer_type\"]\n",
    "\n",
    "# Separate features and predicted value\n",
    "features = num_features + cat_features\n",
    "\n",
    "# preprocess numerical feats:\n",
    "# for most num cols, except the dates, 0 is the most logical choice as fill value\n",
    "# and here no dates are missing.\n",
    "num_transformer = SimpleImputer(strategy=\"constant\")\n",
    "\n",
    "# Preprocessing for categorical features:\n",
    "cat_transformer = Pipeline(steps=[\n",
    "    (\"imputer\", SimpleImputer(strategy=\"constant\", fill_value=\"Unknown\")),\n",
    "    (\"onehot\", OneHotEncoder(handle_unknown='ignore'))])\n",
    "\n",
    "# Bundle preprocessing for numerical and categorical features:\n",
    "preprocessor = ColumnTransformer(transformers=[(\"num\", num_transformer, num_features),\n",
    "                                               (\"cat\", cat_transformer, cat_features)])\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "resort_data = data_cln[data_cln.hotel == 'Resort Hotel']\n",
    "city_data = data_cln[data_cln.hotel == 'City Hotel']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def test_model_1():\n",
    "    inputs = keras.Input(shape=(59, 1,), dtype = \"float32\")\n",
    "    x = layers.Bidirectional(layers.LSTM(256, return_sequences = True))(inputs)\n",
    "    #x = layers.Bidirectional(layers.LSTM(128, return_sequences = True))(x)\n",
    "    x = layers.Bidirectional(layers.LSTM(128, return_sequences = True))(x)\n",
    "    x = layers.Flatten()(x)\n",
    "    # outputs = layers.Reshape((100, 256, 1))(x)\n",
    "    outputs = layers.Dense(1, activation='sigmoid',\n",
    "                    kernel_regularizer=regularizers.l1_l2(l1=1e-5, l2=1e-4))(x)\n",
    "    model = keras.Model(inputs, outputs)\n",
    "    # model.summary()\n",
    "\n",
    "    model.compile(\"adam\", \"binary_crossentropy\", metrics=[\"accuracy\", \"AUC\"])\n",
    "    return model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "tmp = test_model_1()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 10 fold\n",
    "kfolds = 10 # \n",
    "split = KFold(n_splits=kfolds, shuffle=True, random_state=42)\n",
    "\n",
    "X = resort_data.drop([\"is_canceled\"], axis=1)[features]\n",
    "y = resort_data[\"is_canceled\"].to_numpy()\n",
    "\n",
    "X = preprocessor.fit_transform(X)\n",
    "X = X.reshape((-1, 59, 1))\n",
    "result = []\n",
    "\n",
    "for train_index, test_index in split.split(y):\n",
    "    train_x = X[train_index]\n",
    "    train_y = y[train_index]\n",
    "    \n",
    "    test_x = X[test_index]\n",
    "    test_y = y[test_index]\n",
    "    \n",
    "    model = test_model_1()\n",
    "    \n",
    "    history = model.fit(train_x, train_y, batch_size=64, epochs=30, verbose = 2)\n",
    "    pred_y = model.predict(test_x)\n",
    "    result.append({'pred': pred_y, 'test': test_y})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "total_accuracy = []\n",
    "total_f1 = []\n",
    "total_pre = []\n",
    "total_recall = []\n",
    "total_auc = []\n",
    "for i in range(10):\n",
    "    pred = result[i]['pred']\n",
    "    test = result[i]['test']\n",
    "    fpr, tpr, _ = roc_curve(test, pred)\n",
    "    roc_auc = auc(fpr, tpr)\n",
    "    total_auc.append(roc_auc)\n",
    "    plt.plot(fpr, tpr, lw=0.8)\n",
    "    t_acc = []\n",
    "    t_f1 = []\n",
    "    t_pre = []\n",
    "    t_rec = []\n",
    "    for t in np.arange(0,1,0.05):\n",
    "        p_val = np.zeros(pred.shape)\n",
    "        p_val[pred > t] = 1\n",
    "        t_acc.append(accuracy_score(test, p_val))\n",
    "        t_f1.append(f1_score(test, p_val))\n",
    "        t_pre.append(precision_score(test, p_val))\n",
    "        t_rec.append(recall_score(test, p_val)) \n",
    "    total_accuracy.append(np.max(t_acc))\n",
    "    total_f1.append(np.max(t_f1))\n",
    "    total_pre.append(np.max(t_pre))\n",
    "    total_recall.append(np.max(t_rec)) \n",
    "    \n",
    "plt.savefig('resortEncodeDNN.png')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "total_res = {'auc':total_auc, 'acc': total_accuracy, 'f1': total_f1,\n",
    "            'pre': total_pre, 'recall': total_recall}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# total\n",
    "for k, v in total_res.items():\n",
    "    print(k, '\\t', min(v), max(v), np.average(v))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "total_res"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.average(total_res['auc'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.average(total_res['acc'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
